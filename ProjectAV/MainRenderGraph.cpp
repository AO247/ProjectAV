#include "MainRenderGraph.h"
#include "BufferClearPass.h"
#include "LambertianPass.h"
#include "ParticlePass.h"
#include "Source.h"
#include "SkyboxPass.h"
#include "ShadowMappingPass.h"
#include "Source.h"
#include "Sink.h"
#include "RenderTarget.h"
#include "DepthStencil.h"
#include "ComparisonSampler.h"

namespace Rgph
{
	// GetParticlePass implementation remains the same
	Rgph::ParticlePass& MainRenderGraph::GetParticlePass()
	{
		assert(pParticlePass != nullptr && "Particle pass has not been created or linked in MainRenderGraph");
		return *pParticlePass;
	}

	MainRenderGraph::MainRenderGraph(Graphics& gfx)
		: RenderGraph(gfx)
	{
		const unsigned int shadowMapTextureSlot = 3; // Keep track of the slot
		const unsigned int shadowMapSize = 8192;     // Your shadow map dimension
		 
		shadowMap = std::make_shared<Bind::ShaderInputDepthStencil>(gfx, shadowMapSize, shadowMapSize, shadowMapTextureSlot);

		// Make this shadow map resource globally available
		AddGlobalSource(DirectBufferSource<Bind::BufferResource>::Make("shadowMapTextureGlobal", shadowMap));


		// Pass 1: Clear the shadow map 
		{
			auto pass = std::make_unique<BufferClearPass>("clearShadowMap");
 			pass->SetSinkLinkage("buffer", "$.shadowMapTextureGlobal");
			AppendPass(std::move(pass));
		}
		 
		{
			// MODIFIED: Pass shadowMapSize to the constructor
			auto pass = std::make_unique<ShadowMappingPass>(gfx, "shadow", shadowMapSize);

			// The "depthStencil" sink of ShadowMappingPass needs to be set to the
			// *output* of the "clearShadowMap" pass, which is the cleared shadow map itself.
			// This means ShadowMappingPass will render *into* the shadowMap resource.
			pass->SetSinkLinkage("depthStencil", "clearShadowMap.buffer");
			AppendPass(std::move(pass));
		}

		// Pass 3 & 4: Clear main render target and depth stencil
		{
			auto pass = std::make_unique<BufferClearPass>("clearRT");
			pass->SetSinkLinkage("buffer", "$.backbuffer");
			AppendPass(std::move(pass));
		}
		{
			auto pass = std::make_unique<BufferClearPass>("clearDS");
			pass->SetSinkLinkage("buffer", "$.masterDepth");
			AppendPass(std::move(pass));
		}

		// Pass 5: Main scene rendering (LambertianPass)
		{
			auto pass = std::make_unique<LambertianPass>(gfx, "lambertian");
			pass->SetSinkLinkage("renderTarget", "clearRT.buffer");
			pass->SetSinkLinkage("depthStencil", "clearDS.buffer");

			// LambertianPass needs to *read* the shadow map texture generated by the "shadow" pass.
			// The "shadow" pass *outputs* its filled depth buffer via its "depthStencil" source.
			pass->SetSinkLinkage("shadowMap", "shadow.depthStencil");
			AppendPass(std::move(pass));
		}

		// Pass 6: Skybox
		{
			auto pass = std::make_unique<SkyboxPass>(gfx, "skybox");
			// It reads from the output of the lambertian pass...
			pass->SetSinkLinkage("renderTarget", "lambertian.renderTarget");
			pass->SetSinkLinkage("depthStencil", "lambertian.depthStencil");
			AppendPass(std::move(pass));
		}

		SetSinkTarget("backbuffer", "skybox.renderTarget");

		// 4. Draw all transparent geometry (particles) last.
		{
			auto pass = std::make_unique<ParticlePass>(gfx, "particles");
			// It reads from the output of the SKYBOX pass. This means the skybox
			// is already in the color buffer, and particles will blend ON TOP of it.
			pass->SetSinkLinkage("renderTarget", "skybox.renderTarget");
			pass->SetSinkLinkage("depthStencil", "skybox.depthStencil");

			pParticlePass = static_cast<ParticlePass*>(pass.get());
			AppendPass(std::move(pass));
		}

		// 5. The final output of the graph is now the particle pass's render target.
		SetSinkTarget("backbuffer", "particles.renderTarget");

		Finalize();
	}
}